This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  comments/
    comment.entity.ts
  follows/
    follow.entity.ts
  media/
    media.entity.ts
  posts/
    create-post.input.ts
    post-version.entity.ts
    post.entity.ts
    posts.module.ts
    posts.resolver.ts
    posts.service.ts
    update-post.input.ts
  users/
    user.entity.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  chat-message.entity.ts
  chat-room.entity.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.gitignore
.prettierrc
datasource.ts
eslint.config.mjs
nest-cli.json
package.json
README.md
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/comments/comment.entity.ts">
import { ObjectType, Field, ID } from '@nestjs/graphql';
import { forwardRef } from '@nestjs/common';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  DeleteDateColumn,
  OneToMany,
} from 'typeorm';
import { User } from '../users/user.entity';
import { Post } from '../posts/post.entity';

@ObjectType()
@Entity('comments')
export class Comment {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ length: 500 })
  content: string;

  @Field()
  @Column({ name: 'author_id' })
  authorId: string;

  @Field(() => forwardRef(() => User))
  @ManyToOne(() => User, (user) => user.comments, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Field()
  @Column({ name: 'post_id' })
  postId: string;

  @Field(() => forwardRef(() => Post))
  @ManyToOne(() => Post, (post) => post.comments, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'post_id' })
  post: Post;

  @Field(() => ID, { nullable: true })
  @Column({ name: 'parent_comment_id', type: 'uuid', nullable: true })
  parentCommentId: string | null;

  @Field(() => forwardRef(() => Comment), { nullable: true })
  @ManyToOne(() => Comment, (comment) => comment.childComments, {
    onDelete: 'CASCADE',
    nullable: true,
  })
  @JoinColumn({ name: 'parent_comment_id' })
  parentComment: Comment | null;

  @Field(() => [forwardRef(() => Comment)], { nullable: true })
  @OneToMany(() => Comment, (comment) => comment.parentComment)
  childComments: Comment[];

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @Field()
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;

  @Field({ nullable: true })
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz', nullable: true })
  deletedAt: Date;
}
</file>

<file path="src/follows/follow.entity.ts">
import { ObjectType, Field, ID } from '@nestjs/graphql';
import {
  Entity,
  PrimaryGeneratedColumn,
  ManyToOne,
  JoinColumn,
  CreateDateColumn,
  Unique,
  Column,
} from 'typeorm';
import { User } from '../users/user.entity';
import { forwardRef } from '@nestjs/common';

@ObjectType()
@Entity('follows')
@Unique(['followerId', 'followingId'])
export class Follow {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ name: 'follower_id' })
  followerId: string;

  @ManyToOne(() => User, (user) => user.following, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'follower_id' })
  @Field(() => forwardRef(() => User))
  follower: User;

  @Field()
  @Column({ name: 'following_id' })
  followingId: string;

  @ManyToOne(() => User, (user) => user.followers, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'following_id' })
  @Field(() => forwardRef(() => User))
  following: User;

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
}
</file>

<file path="src/media/media.entity.ts">
import { ObjectType, Field, ID, Int, registerEnumType } from '@nestjs/graphql';
import { forwardRef } from '@nestjs/common';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
  DeleteDateColumn,
} from 'typeorm';
import { Post } from '../posts/post.entity';

export enum MediaType {
  IMAGE = 'image',
  VIDEO = 'video',
}

registerEnumType(MediaType, {
  name: 'MediaType',
});

export enum UploadStatus {
  UPLOADING = 'UPLOADING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

registerEnumType(UploadStatus, {
  name: 'UploadStatus',
});

@ObjectType()
@Entity('media')
export class Media {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column()
  url: string;

  @Field(() => MediaType)
  @Column({
    type: 'enum',
    enum: MediaType,
  })
  type: MediaType;

  @Field({ nullable: true })
  @Column({ nullable: true })
  mimetype: string;

  @Field(() => Int, { nullable: true })
  @Column({ type: 'integer', nullable: true })
  filesize: number;

  @Field(() => Int, { nullable: true })
  @Column({ type: 'integer', nullable: true })
  width: number;

  @Field(() => Int, { nullable: true })
  @Column({ type: 'integer', nullable: true })
  height: number;

  @Field(() => UploadStatus)
  @Column({
    type: 'enum',
    enum: UploadStatus,
    default: UploadStatus.UPLOADING,
  })
  status: UploadStatus;

  @Field()
  @Column({ name: 'post_id' })
  postId: string;

  @Field(() => forwardRef(() => Post))
  @ManyToOne(() => Post, (post) => post.media, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'post_id' })
  post: Post;

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @Field({ nullable: true })
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz', nullable: true })
  deletedAt: Date;
}
</file>

<file path="src/posts/create-post.input.ts">
import { InputType, Field } from '@nestjs/graphql';
import { IsNotEmpty, IsString, MaxLength, IsEnum } from 'class-validator';
import { PostType } from './post.entity';

@InputType()
export class CreatePostInput {
  @Field()
  @IsNotEmpty({ message: 'Content cannot be empty.' })
  @IsString()
  @MaxLength(1000, { message: 'Content must be 1000 characters or less.' })
  content: string;

  @Field(() => PostType)
  @IsEnum(PostType)
  type: PostType;

  // The authorId will be extracted from the authenticated user's context (e.g., JWT token)
  // in the resolver/service layer, so it's not part of the client input.
}
</file>

<file path="src/posts/post-version.entity.ts">
import { ObjectType, Field, ID, Int } from '@nestjs/graphql';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
  Unique,
} from 'typeorm';
import { Post } from './post.entity';
import { User } from '../users/user.entity';
import { forwardRef } from '@nestjs/common';

@ObjectType()
@Entity('post_versions')
@Unique(['postId', 'version'])
export class PostVersion {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ name: 'post_id' })
  postId: string;

  @Field(() => forwardRef(() => Post))
  @ManyToOne(() => Post, (post) => post.versions, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'post_id' })
  post: Post;

  @Field({ nullable: true })
  @Column({ name: 'author_id', nullable: true })
  authorId: string;

  @Field(() => forwardRef(() => User), { nullable: true })
  @ManyToOne(() => User, {
    onDelete: 'SET NULL',
    nullable: true,
  })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Field(() => Int)
  @Column()
  version: number;

  @Field()
  @Column({ length: 1000 })
  content: string;

  @Field({ nullable: true })
  @Column({ name: 'edit_reason', type: 'varchar', length: 255, nullable: true })
  editReason: string;

  // Excluded from GraphQL schema as it requires a custom JSON scalar.
  @Column({ name: 'diff_content', type: 'jsonb', nullable: true })
  diffContent: object;

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;
}
</file>

<file path="src/posts/post.entity.ts">
import { ObjectType, Field, ID, Int, registerEnumType } from '@nestjs/graphql';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  OneToMany,
  DeleteDateColumn,
} from 'typeorm';
import { forwardRef } from '@nestjs/common';
import { User } from '../users/user.entity';
import { Comment } from '../comments/comment.entity';
import { PostVersion } from './post-version.entity';
import { Media } from '../media/media.entity';

export enum PostType {
  ANALYSIS = 'ANALYSIS',
  CHEERING = 'CHEERING',
  HIGHLIGHT = 'HIGHLIGHT',
}

registerEnumType(PostType, {
  name: 'PostType',
  description: 'The type of the post, indicating its category.',
});

@ObjectType()
@Entity('posts')
export class Post {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ length: 1000 })
  content: string;

  @Column({
    type: 'enum',
    enum: PostType,
    default: PostType.CHEERING,
  })
  @Field(() => PostType)
  type: PostType;

  @Field()
  @Column({ name: 'author_id' })
  authorId: string;

  @Field(() => forwardRef(() => User))
  @ManyToOne(() => User, (user) => user.posts, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @Field()
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;

  @Field({ nullable: true })
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz', nullable: true })
  deletedAt: Date;

  @Field(() => Int)
  @Column({ name: 'view_count', default: 0 })
  viewCount: number;

  @Field(() => [forwardRef(() => Comment)], { nullable: true })
  @OneToMany(() => Comment, (comment) => comment.post)
  comments: Comment[];

  @Field(() => [forwardRef(() => PostVersion)], { nullable: true })
  @OneToMany(() => PostVersion, (version) => version.post)
  versions: PostVersion[];

  @Field(() => [forwardRef(() => Media)], { nullable: true })
  @OneToMany(() => Media, (media) => media.post)
  media: Media[];
}
</file>

<file path="src/posts/posts.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Post } from './post.entity';
import { PostsResolver } from './posts.resolver';
import { PostsService } from './posts.service';
import { PostVersion } from './post-version.entity';
import { User } from '../users/user.entity';
import { Comment } from '../comments/comment.entity';
import { Media } from '../media/media.entity';
import { Follow } from '../follows/follow.entity';
import { ChatMessage } from '../chat-message.entity';
import { ChatRoom } from '../chat-room.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      Post,
      PostVersion,
      User,
      Comment,
      Media,
      Follow,
      ChatMessage,
      ChatRoom,
    ]),
  ],
  providers: [PostsResolver, PostsService],
  exports: [PostsService],
})
export class PostsModule {}
</file>

<file path="src/posts/posts.resolver.ts">
import { Resolver, Query, Mutation, Args, Int } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { Post } from './post.entity';
import { CreatePostInput } from './create-post.input';
// The UpdatePostInput file will be created in a subsequent step.
// For now, we assume it exists and will be implemented.
import { UpdatePostInput } from './update-post.input';
import { UseGuards } from '@nestjs/common';
// import { GqlAuthGuard } from '../auth/guards/gql-auth.guard';
// import { CurrentUser } from '../auth/decorators/current-user.decorator';
// import { User } from '../users/user.entity';

@Resolver(() => Post)
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {}

  @Query(() => [Post], {
    name: 'posts',
    description: 'Retrieve a list of posts with pagination.',
  })
  findAll(
    @Args('take', {
      type: () => Int,
      defaultValue: 10,
      description: 'Number of items to retrieve.',
    })
    take: number,
    @Args('skip', {
      type: () => Int,
      defaultValue: 0,
      description: 'Number of items to skip.',
    })
    skip: number,
  ): Promise<Post[]> {
    return this.postsService.findAll(take, skip);
  }

  @Query(() => Post, {
    name: 'post',
    nullable: true,
    description: 'Retrieve a single post by its ID.',
  })
  findOne(@Args('id', { type: () => String }) id: string): Promise<Post> {
    return this.postsService.findOne(id);
  }

  @Mutation(() => Post, {
    description: 'Create a new post. Authentication is required.',
  })
  // @UseGuards(GqlAuthGuard)
  createPost(
    @Args('createPostInput') createPostInput: CreatePostInput,
    // @CurrentUser() user: User,
  ): Promise<Post> {
    // TODO: Replace this placeholder with the actual authenticated user's ID.
    const authorId = 'a1b2c3d4-e5f6-7890-1234-567890abcdef';
    return this.postsService.create(createPostInput, authorId);
  }

  @Mutation(() => Post, {
    description: 'Update an existing post. User must be the author.',
  })
  // @UseGuards(GqlAuthGuard)
  updatePost(
    @Args('updatePostInput') updatePostInput: UpdatePostInput,
    // @CurrentUser() user: User,
  ): Promise<Post> {
    // TODO: Add authorization logic to ensure the user is the author of the post.
    // e.g., if (post.authorId !== user.id) throw new ForbiddenException();
    return this.postsService.update(updatePostInput.id, updatePostInput);
  }

  @Mutation(() => Post, {
    description: 'Soft-delete a post. User must be the author.',
  })
  // @UseGuards(GqlAuthGuard)
  removePost(
    @Args('id', { type: () => String }) id: string,
    // @CurrentUser() user: User,
  ): Promise<Post> {
    // TODO: Add authorization logic here as well.
    return this.postsService.remove(id);
  }
}
</file>

<file path="src/posts/posts.service.ts">
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Post } from './post.entity';
import { CreatePostInput } from './create-post.input';
import { UpdatePostInput } from './update-post.input';
import { User } from '../users/user.entity';

@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private readonly postsRepository: Repository<Post>,
  ) {}

  /**
   * Creates a new post.
   * @param createPostInput - The data for the new post.
   * @param author - The user creating the post.
   * @returns The newly created post.
   */
  async create(
    createPostInput: CreatePostInput,
    authorId: string,
  ): Promise<Post> {
    const newPost = this.postsRepository.create({
      ...createPostInput,
      authorId,
    });
    return this.postsRepository.save(newPost);
  }

  /**
   * Finds all posts with pagination.
   * @param take - The number of posts to take.
   * @param skip - The number of posts to skip.
   * @returns An array of posts.
   */
  async findAll(take: number, skip: number): Promise<Post[]> {
    return this.postsRepository.find({
      relations: ['author', 'comments', 'media'], // Eager load relations needed for the feed
      order: { createdAt: 'DESC' },
      take,
      skip,
    });
  }

  /**
   * Finds a single post by its ID.
   * @param id - The ID of the post to find.
   * @returns The found post.
   * @throws NotFoundException if the post does not exist.
   */
  async findOne(id: string): Promise<Post> {
    const post = await this.postsRepository.findOne({
      where: { id },
      relations: ['author', 'comments', 'media', 'versions'],
    });
    if (!post) {
      throw new NotFoundException(`Post with ID "${id}" not found.`);
    }
    return post;
  }

  /**
   * Updates an existing post.
   * @param id - The ID of the post to update.
   * @param updatePostInput - The new data for the post.
   * @returns The updated post.
   * @throws NotFoundException if the post does not exist.
   */
  async update(id: string, updatePostInput: UpdatePostInput): Promise<Post> {
    // `preload` creates a new entity based on the object passed into it.
    // It first looks for an entity with the given ID in the database, and if it finds one,
    // it replaces all its values with the new ones from the plain object.
    const post = await this.postsRepository.preload(updatePostInput);

    if (!post) {
      throw new NotFoundException(`Post with ID "${id}" not found.`);
    }

    // TODO: Add logic here to create a new PostVersion before saving.

    return this.postsRepository.save(post);
  }

  /**
   * Soft-deletes a post.
   * @param id - The ID of the post to remove.
   * @returns The removed post entity (without being saved again).
   * @throws NotFoundException if the post does not exist.
   */
  async remove(id: string): Promise<Post> {
    const post = await this.findOne(id);
    await this.postsRepository.softDelete(id);
    return post; // Return the entity as it was before deletion for the GraphQL response.
  }
}
</file>

<file path="src/posts/update-post.input.ts">
import { InputType, Field, PartialType, ID } from '@nestjs/graphql';
import { IsUUID, IsNotEmpty } from 'class-validator';
import { CreatePostInput } from './create-post.input';

@InputType()
export class UpdatePostInput extends PartialType(CreatePostInput) {
  @Field(() => ID)
  @IsNotEmpty()
  @IsUUID()
  id: string;
}
</file>

<file path="src/users/user.entity.ts">
import { ObjectType, Field, ID, registerEnumType } from '@nestjs/graphql';
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  DeleteDateColumn,
} from 'typeorm';
import { forwardRef } from '@nestjs/common';
import { Post } from '../posts/post.entity';
import { Comment } from '../comments/comment.entity';
import { Follow } from '../follows/follow.entity';

export enum UserRole {
  USER = 'USER',
  INFLUENCER = 'INFLUENCER',
  ADMIN = 'ADMIN',
}

registerEnumType(UserRole, {
  name: 'UserRole',
});

@ObjectType()
@Entity('users')
export class User {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ unique: true, length: 30 })
  nickname: string;

  @Field()
  @Column({ unique: true })
  email: string;

  @Column()
  passwordHash: string;

  @Field({ nullable: true })
  @Column({ name: 'profile_image_url', nullable: true })
  profileImageUrl: string;

  @Field({ nullable: true })
  @Column({ type: 'text', nullable: true })
  bio: string;

  @Field(() => [String])
  @Column({ type: 'text', array: true, default: [] })
  favoriteSports: string[];

  @Field(() => [String])
  @Column({ type: 'text', array: true, default: [] })
  favoriteTeams: string[];

  @Field(() => UserRole)
  @Column({
    type: 'enum',
    enum: UserRole,
    default: UserRole.USER,
  })
  role: UserRole;

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @Field()
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;

  @Field({ nullable: true })
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz', nullable: true })
  deletedAt: Date;

  @Field(() => [forwardRef(() => Post)], { nullable: true })
  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @Field(() => [forwardRef(() => Comment)], { nullable: true })
  @OneToMany(() => Comment, (comment) => comment.author)
  comments: Comment[];

  @Field(() => [forwardRef(() => Follow)], { nullable: true })
  @OneToMany(() => Follow, (follow) => follow.following)
  followers: Follow[];

  @Field(() => [forwardRef(() => Follow)], { nullable: true })
  @OneToMany(() => Follow, (follow) => follow.follower)
  following: Follow[];
}
</file>

<file path="src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
</file>

<file path="src/app.module.ts">
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { GraphQLModule } from '@nestjs/graphql';
import { Module } from '@nestjs/common';
import { join } from 'path';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PostsModule } from './posts/posts.module';
import { config } from 'dotenv';

config();

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
      sortSchema: true,
      playground: true,
    }),
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: process.env.DB_HOST || 'localhost',
      port: parseInt(process.env.DB_PORT || '5432', 10),
      username: process.env.DB_USERNAME || 'postgres',
      password: process.env.DB_PASSWORD || 'password',
      database: process.env.DB_NAME || 'sportcomm',
      entities: [__dirname + '/**/*.entity{.ts,.js}'],
      synchronize: false,
      logging: true,
    }),
    PostsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</file>

<file path="src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="src/chat-message.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { ObjectType, Field, ID } from '@nestjs/graphql';
import { forwardRef } from '@nestjs/common';
import { User } from './users/user.entity';
import { ChatRoom } from './chat-room.entity';

@ObjectType()
@Entity('chat_messages')
export class ChatMessage {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ type: 'text' })
  content: string;

  @Field()
  @Column({ name: 'author_id' })
  authorId: string;

  @Field(() => forwardRef(() => User))
  @ManyToOne(() => User, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Field()
  @Column({ name: 'room_id' })
  roomId: string;

  @Field(() => forwardRef(() => ChatRoom))
  @ManyToOne(() => ChatRoom, (room) => room.messages, {
    onDelete: 'CASCADE',
    nullable: false,
  })
  @JoinColumn({ name: 'room_id' })
  room: ChatRoom;

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @Field()
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;

  @Field({ nullable: true })
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz', nullable: true })
  deletedAt: Date;
}
</file>

<file path="src/chat-room.entity.ts">
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  OneToMany,
  Index,
} from 'typeorm';
import { ObjectType, Field, ID } from '@nestjs/graphql';
import { forwardRef } from '@nestjs/common';
import { ChatMessage } from './chat-message.entity';

@ObjectType()
@Entity('chat_rooms')
export class ChatRoom {
  @Field(() => ID)
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Field()
  @Column({ length: 100, unique: true })
  @Index()
  name: string;

  /**
   * A field to associate the chat room with a specific match or event.
   * This can be a foreign key to a 'matches' table in the future.
   */
  @Field({ nullable: true })
  @Column({ name: 'match_id', nullable: true })
  @Index()
  matchId: string;

  @Field(() => [forwardRef(() => ChatMessage)], {
    nullable: 'itemsAndList',
    description: 'The messages sent in this chat room.',
  })
  @OneToMany(() => ChatMessage, (message) => message.room, {
    cascade: true,
  })
  messages: ChatMessage[];

  @Field()
  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @Field()
  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;

  @Field({ nullable: true })
  @DeleteDateColumn({ name: 'deleted_at', type: 'timestamptz', nullable: true })
  deletedAt: Date;
}
</file>

<file path="src/main.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
</file>

<file path="test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="datasource.ts">
import 'reflect-metadata';
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';

// Load environment variables from a .env file if it exists.
config();

/**
 * This configuration is used by the TypeORM CLI to generate and run migrations.
 * It reads connection details that should ideally come from environment variables
 * for security and flexibility.
 *
 * The paths for `entities` and `migrations` must point to the compiled JavaScript
 * files in the `dist` folder, as the CLI runs against the built output.
 */
export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432', 10),
  username: process.env.DB_USERNAME || 'postgres',
  password: process.env.DB_PASSWORD || 'password',
  database: process.env.DB_NAME || 'sportcomm',
  synchronize: false, // `synchronize: true` should never be used in production.
  logging: true,
  entities: ['dist/**/*.entity.{js,ts}'],
  migrations: ['dist/migrations/*{.js,.ts}'],
  migrationsTableName: 'migrations', // Custom name for the migrations table
};

const AppDataSource = new DataSource(dataSourceOptions);

export default AppDataSource;
</file>

<file path="eslint.config.mjs">
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="package.json">
{
  "name": "be",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@apollo/server": "^4.12.2",
    "@nestjs/apollo": "^13.1.0",
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/graphql": "^13.1.0",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/typeorm": "^11.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "graphql": "^16.11.0",
    "pg": "^8.12.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "typeorm": "^0.3.20"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

</files>
